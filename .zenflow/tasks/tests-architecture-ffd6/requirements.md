# PRD — Tests + Architecture (Arrancador)

## 1) Контекст

Arrancador — desktop launcher на **Tauri (Rust) + React (TypeScript)**.

Ключевые подсистемы:
- UI: `src/pages/*`, `src/components/*`, состояние игр: `src/store/GamesContext.tsx`.
- Bridge: Tauri invoke-обертки: `src/lib/api.ts`.
- Backend (Rust): команды и доменная логика в `src-tauri/src/*`.
- Данные: SQLite, инициализация/миграции в `src-tauri/src/database.rs`.
- Бэкапы: `src-tauri/src/backup.rs` + движок `src-tauri/src/backup/*`.
- Трекинг времени/процессов: `src-tauri/src/tracker.rs` + `src-tauri/src/games.rs`.

В кодовой базе уже заметны признаки «модульного монолита»: UI вызывает команды через `invoke`, а в Rust команда часто совмещает orchestration + доступ к БД + работу с файловой системой/процессами.

Также в UI и Rust встречается «mojibake» в строках интерфейса (например, `src/pages/Library.tsx`, `src-tauri/src/lib.rs`). Это важно не ухудшить при рефакторинге.

## 2) Цель задачи

Сделать приложение:
1. Быстрее (ощутимо лучше по задержкам в UI и тяжёлых операциях)
2. С **идентичным** функционалом для пользователя
3. Без регрессий и с минимизацией вероятности багов в будущем
4. С «превосходным тестированием» (тестовая пирамида + стабильность + репродуцируемость)
5. С улучшенной архитектурой (понятные границы модулей, меньше скрытых сайд-эффектов)

## 3) Пользователи и сценарии

### Основные сценарии пользователя (не должны измениться)
- Просмотр библиотеки игр, поиск, сортировка, избранное.
- Просмотр деталей игры, запуск игры.
- Сканирование EXE/ярлыков и добавление игры в библиотеку.
- Метаданные RAWG: поиск, просмотр деталей, применение к игре.
- Управление бэкапами: поиск сохранений, создание/восстановление/удаление бэкапа, авто-бэкап.
- Трекинг игрового времени и статистика.
- Настройки (путь к Ludusavi, директории сканирования, директория бэкапов, RAWG API key, тема и т.д.).
- Трей-иконка и поведение “hide on close”.

## 4) Область работ (Scope)

### 4.1 Функциональный scope
Функциональность должна остаться **идентичной**:
- Сигнатуры Tauri-команд и контракты данных (в смысле наблюдаемого поведения) не должны ломаться без явной миграции/оберток.
- Поведение UI (роуты, состояния загрузки, ошибки) сохраняется.
- Работа с SQLite сохраняется (включая миграции уже существующих БД).

Допускается:
- Внутренний рефакторинг (переименование внутренних модулей/функций, выделение слоев), если внешнее поведение и данные сохраняются.
- Улучшение сообщений ошибок и логирования, если это не ломает UX.

### 4.2 Тестовый scope
Требуется внедрить и поддерживать следующие уровни тестов.

**Backend (Rust)**
- Unit-тесты: чистая логика (парсинг, вычисления, фильтры, форматирование, построение путей, работа с манифестом бэкапа, сравнение/проверки), без реальных процессов и сети.
- Интеграционные тесты (по возможности): операции с SQLite на временной БД, тестирование миграций/схемы, корректность CRUD для `games`.
- Компонентные тесты: backup engine на `tempfile` каталогах (создание/restore/manifest), без зависимости от реального Ludusavi.

**Frontend (React/TS)**
- Unit-тесты для утилит/хелперов (форматирование, селекторы/фильтрация, преобразования данных).
- Component tests для ключевых компонентов/страниц (рендер, состояния loading/empty/error, интеракции: поиск/фильтр/переключение view, клики по кнопкам, корректный вызов API-оберток).
- Контрактные тесты API-слоя: `src/lib/api.ts` должен быть тестируем через мок `invoke`.

**E2E/Smoke**
- Минимальный smoke-набор сценариев (запуск UI, открытие ключевых страниц) — по согласованию, т.к. E2E для Tauri может требовать отдельной инфраструктуры.

**Общие требования к тестам**
- Тесты должны быть детерминированными: без доступа к реальному RAWG, без зависимости от локальных путей пользователя.
- Тесты должны быть быстрыми: запуск локально и в CI должен занимать приемлемое время.
- Любой найденный баг фиксится через “test first” (минимальный тест, который падает → фикс → зеленый).

### 4.3 Архитектурный scope
Требуется привести код к более защищённой от багов структуре:
- Явные границы модулей: UI → API bridge → backend commands → domain/services → adapters (FS/DB/OS/network).
- Сайд-эффекты (FS/процессы/сеть) должны быть изолированы и по возможности мокабельны.
- Стабильная обработка ошибок: единый формат ошибок и стратегии (логирование + понятные сообщения).
- Минимизация дублирования логики (например, одинаковые SQL SELECT-списки, повторяющиеся преобразования).

## 5) Нефункциональные требования

### 5.1 Производительность
Требование: приложение должно стать **заметно быстрее** в наиболее частых и тяжелых операциях.

Целевые области оптимизации (без привязки к конкретной реализации):
- Быстрый старт и переходы между страницами (уменьшение лишних запросов/перерендеров).
- Работа с большим списком игр (поиск/сортировка/рендер).
- Сканирование и бэкапы: отсутствие блокировок UI, корректный прогресс/отмена, параллельность там, где безопасно.

### 5.2 Надежность
- Никаких регрессий в CRUD/backup/tracker.
- Предсказуемое поведение при ошибках: недоступна БД, нет прав на папку, не найден Ludusavi, RAWG key отсутствует.
- Безопасная работа с путями/ярлыками (особенно Windows).

### 5.3 Поддерживаемость
- Читаемость кода и алгоритмическое качество (простые и понятные структуры данных, отсутствие лишних O(n^2) на больших списках без причины).
- Выделенные “горячие” модули с повышенным покрытием тестами.
- Документация по запуску тестов (команды, переменные окружения, особенности Windows).

### 5.4 Совместимость/локализация
- Текущее состояние UI-строк (включая mojibake/юникод-эскейпы) не ухудшается. Если файл уже содержит mojibake, новые/изменяемые строки в этом файле не должны «частично чиниться» и смешиваться с другой кодировкой.

## 6) Ограничения и допущения

- Проект использует React 18 + Vite; тестовая инфраструктура в `package.json` пока отсутствует.
- Backend использует SQLite через `rusqlite` и OS-специфичные штуки (winreg/windows APIs).
- В тестах запрещено полагаться на реально установленные игры, реальные пути пользователя, реальный RAWG.

## 7) Не входит в задачу (Non-goals)

- Добавление новых пользовательских фич.
- Редизайн UI “ради красоты” (кроме точечных изменений, необходимых для архитектуры/перфоманса/тестируемости).
- Перевод/исправление всей кодировки строк интерфейса (если это не согласовано отдельно).

## 8) Критерии приемки (Acceptance Criteria)

Функционал:
- Все основные пользовательские сценарии из раздела 3 работают как до изменений.

Тестирование:
- Добавлен понятный способ запускать тесты frontend и backend.
- Добавлен репрезентативный набор unit/component/integration тестов, покрывающий критические потоки: CRUD игр, сканирование (на уровне логики), backup engine (на временной ФС), tracker (на уровне логики), базовые UI-сценарии.
- Регрессия фиксится через тест.

Архитектура:
- Сайд-эффекты изолированы и мокабельны.
- Уменьшено дублирование и количество “god functions” в командах.

Производительность:
- Зафиксированы измеримые “узкие места” (до/после) и есть подтверждение улучшения (простые метрики/замеры в dev режиме или синтетические тесты).

## 9) Вопросы для уточнения (нужно от вас)

1) Целевая платформа: только Windows или также macOS/Linux?
2) Нужен ли E2E (например, Playwright) или достаточно unit+component+интеграционных тестов?
3) Какой уровень “покрытия” вы ожидаете в цифрах (например, 80%+), или важнее покрыть критические сценарии без KPI?
4) Допустимо ли менять формат/кодировку UI-строк (починить mojibake) в рамках рефакторинга, или строго оставляем как есть?
5) Есть ли CI, куда нужно добавить запуск тестов (GitHub Actions), или это локальная история?

